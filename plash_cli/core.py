"""The Plash CLI tool"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['PLASH_CONFIG_HOME', 'stop', 'start', 'logs', 'get_global_cfg', 'get_app_id', 'endpoint', 'is_included',
           'create_tar_archive', 'validate_app', 'poll_token', 'login', 'deploy', 'view', 'delete', 'endpoint_func']

# %% ../nbs/00_core.ipynb 2
from fastcore.all import *
from fastcore.xdg import *
import secrets, webbrowser
from httpx import post as xpost, get as xget, delete as xdel
from pathlib import Path
from uuid import uuid4
from time import time, sleep

import io, sys, tarfile

# %% ../nbs/00_core.ipynb 4
PLASH_CONFIG_HOME = xdg_config_home() / 'plash.env'

# %% ../nbs/00_core.ipynb 5
def get_global_cfg():
    """Works for all operating systems."""
    try: return parse_env(fn=Path(PLASH_CONFIG_HOME))
    except FileNotFoundError: raise FileNotFoundError("Please login first by running `plash_login`.")

# %% ../nbs/00_core.ipynb 6
def get_app_id(path:Path):
    plash_app = Path(path) / '.plash'
    if not plash_app.exists(): raise FileNotFoundError(f"File not found: {plash_app=}")
    return parse_env(fn=plash_app)['PLASH_APP_ID']

# %% ../nbs/00_core.ipynb 7
def endpoint(path, local, port=None):
    p = "http" if local else "https"
    d = f"localhost:{port}" if local else "pla.sh"
    return f"{p}://{d}{path}"

# %% ../nbs/00_core.ipynb 8
def is_included(path):
    "Returns True if path should be included in deployment"
    if path.name.startswith('.'): return False
    if path.suffix == '.pyc': return False
    excludes = {'.git', '__pycache__', '.gitignore', '.env', 
                '.pytest_cache', '.venv', 'venv', '.ipynb_checkpoints',
                '.vscode', '.idea', '.sesskey'}
    return not any(p in excludes for p in path.parts)

# %% ../nbs/00_core.ipynb 9
def create_tar_archive(path # Path to directory containing FastHTML app
                      )->io.BytesIO: # Buffer of tar directory
    "Creates a tar archive of a directory, excluding files based on is_included"
    buf = io.BytesIO()
    files = L(Path(path).iterdir()).filter(is_included)

    with tarfile.open(fileobj=buf, mode='w:gz') as tar:
        for f in files: tar.add(f, arcname=f.name)
    buf.seek(0)
    return buf, len(files)

# %% ../nbs/00_core.ipynb 10
def validate_app(path):
    "Validates that the app in the directory `path` is deployable as a FastHTML app"
    print("Analyzing project structure...")

    main_file = Path(path) / "main.py"
    if not main_file.exists():
        print('[red bold]ERROR: Your FastHTML app must have a main.py[/red bold]')
        print(f'Your path is: [bold]{path}[/bold]')
        sys.exit(1)

# %% ../nbs/00_core.ipynb 12
def poll_token(paircode, local, port=None, interval=1, timeout=180):
    "Poll server for token until received or timeout"
    start = time()
    url = endpoint(f"/api/token?paircode={paircode}",local,port)
    while time()-start < timeout:
        resp = xget(url).raise_for_status()
        if resp.text.strip(): return resp.text
        sleep(interval)
        
@call_parse
def login(
    local:bool=False,  # local dev
    port:int=5002      # port for local development
):
    "Authenticate CLI with server and save token"
    paircode = secrets.token_urlsafe(16)
    login_url = xget(endpoint(f"/api/login?paircode={paircode}",local,port)).text
    print(f"Opening browser for authentication:\n{login_url}\n")
    webbrowser.open(login_url)
    
    token = poll_token(paircode, local, port)
    if token:
        Path(PLASH_CONFIG_HOME).write_text(f'export PLASH_TOKEN={token}')
        print(f"Authentication successful! Token saved to {PLASH_CONFIG_HOME}")
    else: print("Authentication timed out.")

# %% ../nbs/00_core.ipynb 14
@call_parse
def deploy(
    path:Path=Path('.'), # Path to project
    local:bool=False,  # local dev
    port:int=5002):
    """ðŸš€ Ship your app to production"""
    token = get_global_cfg()['PLASH_TOKEN']
    print('Initializing deployment...')
    validate_app(path)
    tarz, filecount = create_tar_archive(path)

    plash_app = Path(path) / '.plash'
    if not plash_app.exists():
        # Create the .plash file and write the app name
        plash_app.write_text(f'export PLASH_APP_ID=fasthtml-app-{str(uuid4())[:8]}')
    aid = parse_env(fn=plash_app)['PLASH_APP_ID']
    headers = {'Authorization': f'Bearer {token}'}
    print(f'Uploading {filecount} files...')
    resp = xpost(endpoint("/api/upload",local,port), headers=headers, files={'file': tarz}, timeout=300.0, data={'aid': aid})
    if resp.status_code == 200: 
        print('âœ… Upload complete! Your app is currently being built.')
        if local: print(f'It will be live at http://{aid}.localhost')
        else: print(f'It will be live at https://{aid}.pla.sh')
    else:
        print(f'Failure {resp.status_code}')
        print(f'Failure {resp.text}')

# %% ../nbs/00_core.ipynb 16
@call_parse
def view(
    path:Path=Path('.'), # Path to project
    local:bool=False,  # local dev
    port:int=5002      # port for local development
):
    aid = get_app_id(path)
    if local: url = f"http://{aid}.localhost"
    else: url = f"https://{aid}.pla.sh"
    print(f"Opening browser to view app :\n{url}\n")
    webbrowser.open(url)

# %% ../nbs/00_core.ipynb 18
@call_parse
def delete(
    path:Path=Path('.'), # Path to project
    local:bool=False,  # local dev
    port:int=5002,
    force:bool=False): # Skip confirmation prompt
    'Delete your deployed app'
    token = get_global_cfg()['PLASH_TOKEN']
    aid = get_app_id(path)
    
    if not force:
        confirm = input(f"Are you sure you want to delete app '{aid}'? This action cannot be undone. [y/N]: ")
        if confirm.lower() not in ['y', 'yes']:
            print("Deletion cancelled.")
            return
    
    print(f"Deleting app '{aid}'...")
    r = xdel(endpoint(f"/api/delete?aid={aid}",local,port), headers={'Authorization': f'Bearer {token}'})
    return r.content

# %% ../nbs/00_core.ipynb 20
def endpoint_func(endpoint_name):
    'Creates a function for a specific API endpoint'
    @call_parse
    def func(
        path:Path=Path('.'), # Path to project
        local:bool=False,    # local dev
        port:int=5002):      # port for local development
        token = get_global_cfg()['PLASH_TOKEN']
        aid = get_app_id(path)  # Using get_app_id instead of directly parsing
        r = xpost(endpoint(f"/api/{endpoint_name}", local, port), 
                    headers={'Authorization': f'Bearer {token}'}, 
                    data={'aid': aid})
        return r.content
    
    # Set the function name and docstring
    func.__name__ = endpoint_name
    func.__doc__ = f"Access the '{endpoint_name}' endpoint for your app"
    
    return func

# Create endpoint-specific functions
stop = endpoint_func('stop')
start = endpoint_func('start')
logs = endpoint_func('logs')
