"""The Plash CLI tool"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['PLASH_CONFIG_HOME', 'TOKEN_FILE', 'get_global_cfg', 'is_included', 'create_tar_archive', 'validate_app', 'deploy',
           'poll_token', 'login', 'view', 'logs']

# %% ../nbs/00_core.ipynb 2
from fastcore.all import *
from fastcore.xdg import *
import secrets, webbrowser
from httpx import post as xpost, get as xget
from pathlib import Path
from uuid import uuid4
from time import time, sleep

import io, sys, tarfile

# %% ../nbs/00_core.ipynb 3
# TODO: harmonize this (move auth_token.txt content into plash.env?)
PLASH_CONFIG_HOME = xdg_config_home() / 'plash.env'
TOKEN_FILE = PLASH_CONFIG_HOME.parent / 'plash_auth_token.txt'

# %% ../nbs/00_core.ipynb 4
def get_global_cfg():
    """Works for all operating systems."""
    try: return parse_env(fn=Path(PLASH_CONFIG_HOME))
    except FileNotFoundError: 
        Path(PLASH_CONFIG_HOME).touch()
    return parse_env(fn=Path(PLASH_CONFIG_HOME))

# %% ../nbs/00_core.ipynb 5
def is_included(path):
    "Returns True if path should be included in deployment"
    if path.name.startswith('.'): return False
    if path.suffix == '.pyc': return False
    excludes = {'.git', '__pycache__', '.gitignore', '.env', 
                '.pytest_cache', '.venv', 'venv', '.ipynb_checkpoints',
                '.vscode', '.idea', '.sesskey'}
    return not any(p in excludes for p in path.parts)

# %% ../nbs/00_core.ipynb 6
def create_tar_archive(path # Path to directory containing FastHTML app
                      )->io.BytesIO: # Buffer of tar directory
    "Creates a tar archive of a directory, excluding files based on is_included"
    buf = io.BytesIO()
    files = L(Path(path).iterdir()).filter(is_included)

    with tarfile.open(fileobj=buf, mode='w:gz') as tar:
        for f in files: tar.add(f, arcname=f.name)
    buf.seek(0)
    return buf, len(files)

# %% ../nbs/00_core.ipynb 7
def validate_app(path):
    "Validates that the app in the directory `path` is deployable as a FastHTML app"
    print("Analyzing project structure...")

    main_file = Path(path) / "main.py"
    if not main_file.exists():
        print('[red bold]ERROR: Your FastHTML app must have a main.py[/red bold]')
        print(f'Your path is: [bold]{path}[/bold]')
        sys.exit(1)

# %% ../nbs/00_core.ipynb 8
@call_parse
def deploy(
    path:Path=Path('.'), # Path to project
    local:bool=False,  # local dev
    port:int=5002):
    """ðŸš€ Ship your app to production"""
    print('Initializing deployment...')
    validate_app(path)
    tarz, filecount = create_tar_archive(path)

    plash_app = Path(path) / '.plash'
    if not plash_app.exists():
        # Create the .plash file and write the app name
        plash_app.write_text(f'export PLASH_APP_ID=fasthtml-app-{str(uuid4())[:8]}')
    aid = parse_env(fn=plash_app)['PLASH_APP_ID']
    plash_token = TOKEN_FILE.read_text()
    base_url = 'https://pla.sh' if not local else f'http://localhost:{port}'
    url = base_url+"/api/upload"
    headers = {'Authorization': f'Bearer {plash_token}'}
    print(f'Uploading {filecount} files...')
    resp = xpost(url, headers=headers, files={'file': tarz}, timeout=300.0,
                data={'aid': aid})
    if resp.status_code == 200: 
        print('âœ… Upload complete! Your app is currently being built.')
        print(f'It will be live at https://{aid}.pla.sh')
    else:
        print(f'Failure {resp.status_code}')
        print(f'Failure {resp.text}')

# %% ../nbs/00_core.ipynb 11
def poll_token(paircode, base_url, interval=1, timeout=180):
    "Poll server for token until received or timeout"
    start = time()
    while time()-start < timeout:
        resp = xget(f"{base_url}/api/token?paircode={paircode}").raise_for_status()
        if resp.text.strip(): return resp.text
        sleep(interval)
        
@call_parse
def login(
    local:bool=False,  # local dev
    port:int=5002      # port for local development
):
    "Authenticate CLI with server and save token"
    base_url = 'https://pla.sh' if not local else f'http://localhost:{port}'
    paircode = secrets.token_urlsafe(16)
    login_url = xget(base_url+f'/api/login?paircode={paircode}').text
    print(f"Opening browser for authentication:\n{login_url}\n")
    webbrowser.open(login_url)
    
    token = poll_token(paircode, base_url)
    if token:
        Path(TOKEN_FILE).write_text(token)
        print(f"Authentication successful! Token saved to {TOKEN_FILE}")
    else: print("Authentication timed out.")

# %% ../nbs/00_core.ipynb 13
@call_parse
def view(
    path:Path=Path('.'), # Path to project
):
    app_id = (Path(path) / '.plash').read_text().split("=")[-1]
    url = f"https://{app_id}.pla.sh"
    print(f"Opening browser to view app :\n{url}\n")
    webbrowser.open(url)

# %% ../nbs/00_core.ipynb 15
@call_parse
def logs(
    path:Path=Path('.'), # Path to project
    local:bool=False,  # local dev
    port:int=5002):
    plash_app = Path(path) / '.plash'
    if not plash_app.exists():
        print(f"File not found: {plash_app=}")
        return
    aid = parse_env(fn=plash_app)['PLASH_APP_ID']
    plash_token = TOKEN_FILE.read_text()
    base_url = 'https://pla.sh' if not local else f'http://localhost:{port}'
    url = base_url+"/api/logs"
    headers = {'Authorization': f'Bearer {plash_token}'}
    resp = xpost(url, headers=headers, data={'aid': aid})
    return resp.content
